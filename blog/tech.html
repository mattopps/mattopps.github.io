<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../stylesheets/default.css"> 
    <link rel="stylesheet" type="text/css" href="../stylesheets/blog.css"> 
      <title></title>
      <meta charset="UTF-8"> 
  </head>

<body>
  <nav>
    <a href="blog-template.html"> My DBC blog</a>
    <a href="#"> Projects</a>   
    <a href="#"> Resume</a>   
    <a href="about.html"> About This Guy</a>
  </nav>
  
  <main>
    <div class = "title"><h1>Sorting</h1>
    <h2></h2>
    <h4>12/12/15</h4></div>

    <section class = "body">
      <p> Hello Again Blog!</p>
      
      <p>Let's say you were looking in an alphabetical listing of takeout places by type, and you wanted pizza. It would be verrrrry silly to start all the way at the beginning of the list at A and go through all the letters to get to P. It would be the absolute worst idea if you knew you needed a zucchini bread recipe to start looking through your recipe book at the A's (really it is a terrible idea to make zucchini bread. A great idea would be Banana Bread. Two birds, one stone.) </p>
    
      <p> So what would be a better way to look through a list? Linear front to back is perhaps the least optimal sort method. Let's look at a few different ways to sort data: merge sort, quick sort, bubble sort.</p> 
      <p>Merge Sort is a very popular method and I saw several similar and apt descriptions of this method by way of a little story. If you were searching for something being held by one person in a large group. Say as a goof somebody "borrowed" your phone. Asking each person one at a time, which would take as long as the questioning process per person took multiplied by the size of the group, should the phone be held by a person near the end of the group. Instead separate the group into two groups. Ask the first group if anybody has the phone. if they do the entire other group no longer needs to be looked at. If not, then somebody in the other group has the phone. So everybody in the first group can go without further inspection. Repeat that process a few more times and you will have the phone in a tiny fraction of the time and number of questions relative to a linear one at a time inspection process (unless the first or second person asked had the phone. Obviously that is not very likely). As it relates directly to data, merge sort involves splitting a large list of elements into many smaller sublists and compares the items of each sublist and sorts them individually. The method begins to add some of the sorted sublists together and then resorts until all the sorted sublists are added together to compare a sorted list of the original elements.</p>

      <p>A quicksort separates a group with reference to one of its members, called a pivot. EX if you had a 100 people all ranging in height from 4'to 6', and you wanted to create a cool picture of them all in height order. First have everybody over 5' (a height of 5" being the first pivot) go to the blue side of the room. Now you will have three sub groups. All the people over 5' in the blue room, the exactly 5ft people and the 4ft to 4'11" people. Then pick another random height by which to sort for each of the two subgroups other than the original pivot of 5'. So 4' to 4'11" would sort themselves again by under or over 4'8" and 5'1" to 6' would sort by under or over 5'9". Eventually everyone will be in order. The reason this can be quick is twofold. Firstly, many people standing together will have already been randomly standing in height order or close to it. Secondly, many people will be the same height. (when sorting numbers, for example, there are only 10 digits) So the sort doesn't actually take the maximum number of re-sorts for as many increments as are possible. </p>

      <p>A bubble sort is a much slower type of sort that methodically looks over the list one pair of items at a time and sorts the pair. Then the next pair is compared and sorted if necessary. When the sort method reaches the end of the list it goes back to the beginning and starts again. The process is only finished if the sort method can do a whole sweep without having to switch anything. In other words, even after it has sorted everything correctly, it still looks again one last time. Let's say a bubble sort was being used to sort the following list: 3,5,2,1. On the first pass it would compare 3, and 5. They're properly sorted. Then it compares 5 and 2 and switches the order, then it compares 5 and 1 and switches the order. After 1 sweep the new semi-sorted list is: 3,2,1,5. But this is still very much not sorted. so then it will compare each pair again. which switches the order from 3,2 to 2,3. Then the next pair is sorted so the 3 and the 1 are switched. The 3 and 5 are properly sorted. So after two sweeps the list looks like this: 2,1,3,5. One more sweep through switches the 1 and 2 and leaves the 3 and 5. The it attempts to sort one more time and doesn't need to sort anything and is done. A merge sort here would have separated 3,5,2,1 into two lists 3,5 and 2,1. which then becomes 1,2 then compares 3,5 and 1,2 and puts the 1 before the three and then the 2 before the three.  </p>
      <p></p></section></main>

          <h2><a href="git.html"> In the Beginning There Was Git!</a></h2>
          <h2><a href="css-blog.html"> And then there was css</a></h2>
          <h2><a href="arrays-hashes.html">Arrays or Hashes: or Both?</a></h2>
          <h2><a href="enumerable-methods.html">Cycling: An Enumerable</a></h2>
          <h2><a href="ruby-classes.html">Class is in Session</a></h2>
          <h4><a href="JS.html">JS Ruby Throwdown</a></h4></div>
          <h4><a href="tech.html">Sort This</a></h4></div>

          

<!-- 
          <h4> Links</h4>
            <a href="#"> </a>
 -->
          <h3>Social Media</h3>
            <a href="#"> Github</a>
            <a href="#"> LinkedIn</a>
            <a href="#"> Facebook</a>

</body>
</html>
 
